{"pages":[{"title":"tags","permalink":"https://justinchang.ddns.net/tags/index.html","text":""},{"title":"categories","permalink":"https://justinchang.ddns.net/categories/index.html","text":""}],"posts":[{"title":"Client_Use_Of_Iframe_Without_Sandbox","permalink":"https://justinchang.ddns.net/2021/05/05/Client-Use-Of-Iframe-Without-Sandbox/","text":"Client Use Of Iframe Without Sandbox使用 Sandbox 屬性來限制 Iframe 的行為，單獨使用時代表全部的行為都禁止，也可以加入一至多個屬性，常用的屬性如下： allow-same-origin : 將 Iframe 當作同源 allow-scripts : 允許可以執行Script，但不包含可以開新視窗 allow-popups : 允許可以開新視窗 allow-forms : 允許可以提交表單 12&lt;iframe id=&quot;iframeId&quot; src=&quot;oooooo.html&quot; sandbox=&quot;allow-same-origin allow-scripts allow-popups allow-forms&quot;&gt;&lt;/iframe&gt; 參考MDNClient Use Of Iframe Without Sandbox error - Checkmarx","categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"}]},{"title":"Client_Potential_XSS","permalink":"https://justinchang.ddns.net/2021/05/05/Client-Potential-XSS/","text":"Client Potential XSS主要是不可以信任使用的輸入的資料，可以會隱藏一些程式碼等等，所以也是一樣將使用者輸入的資料所Encode 123string Referer = Request.QueryString[&quot;Referer&quot;];Response.BinaryWrite(encoder.HtmlEncode(Referer, true));","categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"}]},{"title":"Unencrypted_Web_Config_File_And_Password_in_Configuration_File","permalink":"https://justinchang.ddns.net/2021/05/05/Unencrypted-Web-Config-File-And-Password-in-Configuration-File/","text":"Unencrypted Web Config File &amp;&amp; Password in Configuration File 這是指在Config檔中，使用名文儲存資料庫連線字串，這可能使非預期使用者也能夠訪問資料庫，所以要將資料庫連線字串加密，操作方式參考encrypt-and-decrypt-connectionstring-in-web-config-file cd C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319 加密 .\\ASPNET_REGIIS -pef &quot;connectionStrings&quot; &quot;E:\\Config&quot; 解密 .\\ASPNET_REGIIS -pdf &quot;connectionStrings&quot; &quot;E:\\Config&quot; ASPNET_REGIIS -{pef 加密 | pdf 解密} “{加密的部份}” “{路徑}”","categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"}]},{"title":"Insufficient_Connection_String_Encryption","permalink":"https://justinchang.ddns.net/2021/05/05/Insufficient-Connection-String-Encryption/","text":"Insufficient Connection String Encryption在連線字串加上「TrustServerCertificate=true」，使得連線過程是使用加密的過程","categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"}]},{"title":"HttpOnlyCookies_In_Config","permalink":"https://justinchang.ddns.net/2021/05/05/HttpOnlyCookies-In-Config/","text":"HttpOnlyCookies In Config主要問題是要將Cookies設定為不可以被前端「語法」讀取，所以在後端設定Cookies時必需加上「限制」，或在Web.config加上全域的設定 web.config 設定 httpOnlyCookies : 只能透過http存取Cookies，也就是不能透過js存取 requireSSL：限制只能透過SSL存取 123456&lt;system.web&gt; . . . &lt;httpCookies httpOnlyCookies=&quot;true&quot; requireSSL=&quot;true&quot; /&gt;&lt;/system.web&gt;","categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"}]},{"title":"Eclipse開發JAVA-mybatis-GettingStarted","permalink":"https://justinchang.ddns.net/2021/04/20/Eclipse%E9%96%8B%E7%99%BCJAVA-mybatis-GettingStarted/","text":"pox.xml 加入 mybatis dependency要dependency的套件版本可以到mybatis查詢目前最新的版本號。 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt; 在 application.properties 設定連線資訊1234url=jdbc:oracle:thin:@localhost:1521:xedriver=oracle.jdbc.driver.OracleDriverusername=SYSTEMpassword=1qaz@WSX 新增 mybatis-config.xml這邊要注意的是 $&#123;xxxx&#125;要與 application.properties 的設定相同 mapper的路徑要設定正確 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 載入設定檔案 --&gt; &lt;properties resource=&quot;application.properties&quot;&gt; &lt;/properties&gt; &lt;!-- 設定連線資訊 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 每一個Table的Mapper檔案 --&gt; &lt;mappers&gt; &lt;mapper class=&quot;Mapper.AccountMapper&quot;/&gt;&lt;/mappers&gt;&lt;/configuration&gt; 設定資料模型12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class AccountPo&#123; public String ID; public String Name; public String Email;&#125; 設定Mapper12345@Mapperpublic interface AccountMapper&#123; @Select(&quot;select * from ACCOUNT&quot;) Collection &lt;AccountPo&gt; SelectAll();&#125; 連線測試1234567891011121314151617181920String resource = &quot;mybatis-config.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);SqlSession sqlSession=null;try&#123; sqlSession=sqlSessionFactory.openSession(); AccountMapper accountMapper=sqlSession.getMapper(AccountMapper.class); Collection&lt;AccountPo&gt; account=accountMapper.SelectAll(); account.forEach(s -&gt; System.out.println(s.Name)); sqlSession.commit();&#125; catch(Exception ex)&#123; sqlSession.rollback();&#125; finally&#123; if(sqlSession!=null)&#123; sqlSession.close(); &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/categories/JAVA/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://justinchang.ddns.net/tags/Eclipse/"},{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/tags/JAVA/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://justinchang.ddns.net/tags/Mybatis/"},{"name":"ORM","slug":"ORM","permalink":"https://justinchang.ddns.net/tags/ORM/"}]},{"title":"Client_DOM_XSS","permalink":"https://justinchang.ddns.net/2021/04/16/Client-DOM-XSS/","text":"Client DOM XSS由前端取得的值，在程式的流程當中，沒有過濾(處理)直接拿來使用，會有機會被注入非法的字串。例如： 12var source = window.location.origin //直接取得來自於User可修改的的值document.write(source()) //並接直接使用 可以將取得的內容作encode，並包一層function，如此就可以回避「直接」使用「值」，同時也處理內藏程式碼的問題。 12var source = function() &#123; return encodeURI(window.location.origin)&#125;document.write(source())","categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"}]},{"title":"原碼掃瞄弱點處理","permalink":"https://justinchang.ddns.net/2021/04/16/%E5%8E%9F%E7%A2%BC%E6%8E%83%E7%9E%84%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/","text":"Client Use Of Iframe Without Sandbox使用 Sandbox 屬性來限制 Iframe 的行為，單獨使用時代表全部的行為都禁止，也可以加入一至多個屬性，常用的屬性如下： allow-same-origin : 將 Iframe 當作同源 allow-scripts : 允許可以執行Script，但不包含可以開新視窗 allow-popups : 允許可以開新視窗 allow-forms : 允許可以提交表單 12&lt;iframe id=&quot;iframeId&quot; src=&quot;oooooo.html&quot; sandbox=&quot;allow-same-origin allow-scripts allow-popups allow-forms&quot;&gt;&lt;/iframe&gt; 參考MDNClient Use Of Iframe Without Sandbox error - Checkmarx","categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"}]},{"title":"OracleXE18C建置byWin10","permalink":"https://justinchang.ddns.net/2021/04/16/OracleXE18C%E5%BB%BA%E7%BD%AEbyWin10/","text":"OracleXE是免費的版本的版，可以用來商用，雖然是免費但有一些限制，但用來作一些簡單的系統或開發測試已經是足夠了。限制如下： 只能使用3個資料庫 只能使用2顆cpu 只能使用2GRAM 每一個資料庫大小只能使用到12GB 下載ＯracleOracle XE 18C 下載時必需要登入Oracle，如果沒有帳號時必須先注冊 安裝歷程 在執行setup.exe後，會出現安裝畫面 授權合約畫面 調整安裝目錄 設定密碼 Oracle會使用三個路徑 開始安裝 如果是使用WindowDefender，會出現需要允許開放防火牆限制，後會繼續進行安裝程序 如果安裝失敗，必需要把已安裝的服務全部刪除可以使用 sc delete &quot;服務名稱&quot;，把全部的Oracle刪除，之後再重新執行安裝參考 Cannot reinstall XE 18c after doing an uninstall 連線測試可以依照使用的程式語言參考Oracle Database XE Quick Start SQL Developer 測試連線 JAVA 測試連線 安裝JDBC 直接修改pom.xml加上會失敗，是因為jdbc.jar必須自己下載不可以透過mvan進行自動安裝 下載, 如果有已安裝oracle 在CMD管理者模式下指令 切換到專案目錄下 mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc18 -Dversion=18.3 -Dpackaging=jar -Dfile=E:\\Downloads\\ojdbc8.jar pom.xml加上dependency 依照版設定，這邊是使用ojdbc8 12345 &lt;dependency&gt; &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt; &lt;artifactId&gt;ojdbc8&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 連線測試程試碼 123456789101112131415161718192021222324try&#123; //step1 load the driver class Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //step2 create the connection object Connection con=DriverManager.getConnection( &quot;jdbc:oracle:thin:@localhost:1521:xe&quot;,&quot;SYSTEM&quot;,&quot;1qaz@WSX&quot;); //step3 create the statement object Statement stmt=con.createStatement(); //step4 execute query ResultSet rs=stmt.executeQuery(&quot;select * from HELP&quot;); while(rs.next()) &#123; System.out.println(rs.getString(1)+&quot; &quot;+rs.getString(2)+&quot; &quot;+rs.getString(3)); &#125; //step5 close the connection object con.close(); &#125;catch(Exception e)&#123; System.out.println(e); e.printStackTrace();&#125; 參考：Java Database Connectivity with Oracle C# 測試連線 …待續 參考Oracle Database XE Quick StartInstallation Guide for Microsoft WindowsOracle Database XE Frequently Asked QuestionsCannot reinstall XE 18c after doing an uninstall","categories":[{"name":"Oracle","slug":"Oracle","permalink":"https://justinchang.ddns.net/categories/Oracle/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://justinchang.ddns.net/tags/Oracle/"},{"name":"Win10","slug":"Win10","permalink":"https://justinchang.ddns.net/tags/Win10/"}]},{"title":"VSCode開發JAVA-環境建置","permalink":"https://justinchang.ddns.net/2021/04/15/VSCode%E9%96%8B%E7%99%BCJAVA-%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE/","text":"前陣子試過用Eclipse來建置JAVA開發環境，現在來試試地表上最強的開發工具VSCode MavenMaven類似NuGet，作套件管理，下載Maven Download，之後解完壓縮後，在「環境變數」PATH設定此路徑。 JDKJava Development Kit（JDK）是昇陽電腦針對Java開發人員發布的免費軟體開發套件（SDK，Software development kit）。 JDK 8JDK 11 參考維基百科 JDK VSCode因為己經使用VSCode安裝版，也裝了不少套件，為了本次的案子，想要使用VSCode來開發，所以使用免安裝的方式，來建置JAVA開發環境。 VSCode 套件Java Extension Pack這是Microsoft所包裝的Pack，進面包含： Visual Studio IntelliCode Language Support for Java(TM) by Red Hat Debugger for Java Maven for Java Java Test Runner Project Manager for Java Spring Boot Extension Pack這是開發SpringFormwork使用的想關套件，進面包含： Spring Boot Tools : 必需要使用JDK11以上 Spring Initializr Java Support Spring Boot Dashboard Cloudfoundry Manifest YML Support Concourse CI Pipeline Editor 簡單操作範例","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/tags/JAVA/"},{"name":"VSCode","slug":"VSCode","permalink":"https://justinchang.ddns.net/tags/VSCode/"},{"name":"Spring","slug":"Spring","permalink":"https://justinchang.ddns.net/tags/Spring/"},{"name":"Web","slug":"Web","permalink":"https://justinchang.ddns.net/tags/Web/"}]},{"title":"Eclipse開發JAVA-環境建置","permalink":"https://justinchang.ddns.net/2021/04/14/Eclipse%E9%96%8B%E7%99%BCJAVA-%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE/","text":"最近被問到要不要把dotNet改版成java，所以先來建置一下開發環境看看java是怎麼開發Web，順便記錄一下 MavenMaven類似NuGet，作套件管理，下載Maven Download，之後解完壓縮後，在「環境變數」PATH設定此路徑。 JDKJava Development Kit（JDK）是昇陽電腦針對Java開發人員發布的免費軟體開發套件（SDK，Software development kit）。 JDK 8JDK 11 參考維基百科 JDK Eclipse 下載 如果在不正常停止debug時，會遇到再次啟動時埠已被佔用而啟動失敗時，首先要先切換為debug視窗(在右上角) 切換後在左邊窗列會有兩個Tab，將Tab切換為debug 如果發現有尚未停止的執行緒，先選擇要停止的程序再選擇停止 使用start.spring.io產生初始專案 到Start Spring，選擇要使用執行的環境與要使用的套件，會直接產生專案範本，之後就可以匯入開發工具中。 匯入完成後，可以先在DemoApplication.java定義預設的回應方式 1234567891011121314@SpringBootApplication(scanBasePackages = &quot;Controllor&quot;)@RestControllerpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125; @RequestMapping(&quot;/&quot;) public String Index() &#123; return &quot;Hello World&quot;; &#125; &#125; 如果Controller在另外的package時，必須指定scan的package@SpringBootApplication(scanBasePackages = &quot;指定的package&quot;)詳細可以參考SpringBootApplication用法 一個Controller範例123456789101112131415161718@RestControllerpublic class SayHiController &#123; @RequestMapping(&quot;/SayHi&quot;) public UserModel SayHi(@RequestBody(required = false) UserModel user) &#123; if(user==null) user = new UserModel(); if(user.name==null || user.name ==&quot;&quot;) &#123; user.name = &quot;Demo&quot;; &#125; return user; &#125; &#125;class UserModel &#123; public String name;&#125; application.properties 設定當有選擇資料庫套件(ex:mybatis) 執行時，如果出現「Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.」，時必需要在application.properties參數設定 12345678//使用資料庫連線方式spring.datasource.url=jdbc:sqlserver://LAPTOP-VL2GOT2H\\\\SQLEXPRESS;databaseName=Northwindspring.datasource.username=&#123;username&#125;spring.datasource.password=&#123;password&#125;spring.datasource.driverClassName=com.microsoft.sqlserver.jdbc.SQLServerDriver//改變啟動時後的連結埠server.port=1234 參考MSSQL 設定參考","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/categories/JAVA/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"https://justinchang.ddns.net/tags/Eclipse/"},{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/tags/JAVA/"},{"name":"Spring","slug":"Spring","permalink":"https://justinchang.ddns.net/tags/Spring/"},{"name":"Web","slug":"Web","permalink":"https://justinchang.ddns.net/tags/Web/"}]},{"title":"使用Cordova開發App-開發環境","permalink":"https://justinchang.ddns.net/2021/04/12/%E4%BD%BF%E7%94%A8Cordova%E9%96%8B%E7%99%BCApp-%E9%96%8B%E7%99%BC%E7%92%B0%E5%A2%83/","text":"開發環境建置NodeNode Download &amp;&amp; Install JDK 1.8.XXJDK Download &amp;&amp; Install Android StudioAndroid Download &amp;&amp; Install 在「Tools/SDK Manager/System Setting/Android SDK」中的Android SDK Location裡面必需設定在PATH的「Android_SDK_Home」與「Android_Home」中 Gradle依照官網安裝Gradle Install，假設在Windows下安裝直接下載解壓後，要在環境變數PATH中設定路徑。 如果沒有安裝會出現Error:Checking Java JDK and Android SDK versionsANDROID_SDK_ROOT=undefined (recommended setting)ANDROID_HOME=C:\\Android\\android-sdk (DEPRECATED)Using Android SDK: C:\\Android\\android-sdkCould not find an installed version of Gradle either in Android Studio,or on your system to install the gradle wrapper. Please include gradlein your path, or install Android Studio 關閉 HyperV如果有安裝HyperV，必需要關閉否則模擬器會無法啟動bcdedit /set hypervisorlaunchtype off cordova install &amp;&amp; hello world demonpm install -g cordovacordova create hello com.example.hello HelloWorldcd hellocordova platform add android 增加建置平台cordova build 全部平台一起編譯cordova build android 指定Android平台編譯cordova emulate android 編譯&amp;啟動已編譯好的apk 主要開發目錄(www)只要在www放入網站就可以編譯成App 使用cordova emulate android 直接更新畫面 使用Chrome Debug 在Chrome上 chrome://inspect/#devices 在編譯時的 cordova build --debug android 移植app要調整的程式碼document.alert在APP中沒有Window.alert，所以必需改寫為 window.alert = navigator.notification.alert; 123if(navigator.notification)&#123; window.alert = navigator.notification.alert;&#125; 如果完整路徑使用 window.location.href 會跳轉到預設的 Browser","categories":[],"tags":[]},{"title":"使用Cookie實作Login-使用Authentication","permalink":"https://justinchang.ddns.net/2021/04/09/%E4%BD%BF%E7%94%A8Cookie%E5%AF%A6%E4%BD%9CLogin-%E4%BD%BF%E7%94%A8Authentication/","text":"雖然可以完全可以自行完成Login的功能，但在Asp.net Core中有提供Authentication的Service與Middleware，可以更完整及快速開發。 Startup.cs 中的設定Service的設定123456public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews(); services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme); //使用預設的Scheme&#125; Middleware的設定","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"https://justinchang.ddns.net/categories/ASP-NET-Core/"}],"tags":[{"name":"Without Identity, Login,ASP.NETCore,Cookie","slug":"Without-Identity-Login-ASP-NETCore-Cookie","permalink":"https://justinchang.ddns.net/tags/Without-Identity-Login-ASP-NETCore-Cookie/"}]},{"title":"使用Cookie實作Login-簡易登入","permalink":"https://justinchang.ddns.net/2021/04/06/%E4%BD%BF%E7%94%A8Cookie%E5%AF%A6%E4%BD%9CLogin-%E7%B0%A1%E6%98%93%E7%99%BB%E5%85%A5/","text":"實作登入與登出實作流程大致上與使用Session實作Login的流程相同，只有儲存的方式改變為使用Cookie，剩下Controller在處理登入與登出的部份，先暫時空者。 123456789101112131415161718192021222324252627//Controller public class AccountController : Controller &#123; public IActionResult Index() &#123; return View(); &#125; public IActionResult Login(LoginModel data) &#123; if (data.Badge == &quot;Justin&quot; &amp;&amp; data.CipherCode == &quot;1111111111&quot;) &#123; //to do append cookie return RedirectToAction(nameof(HomeController.Index), &quot;Home&quot;); &#125; return View(nameof(HomeController.Index), data); &#125; public IActionResult Logout() &#123; //to do clean cookie return View(); &#125; &#125; 登入後寫入與登出後刪除Cookie 雖然這樣可以辦視出是否有登入，但無法辨斷出登入者是誰，所以調整為寫入登入都是的帳號 1HttpContext.Response.Cookies.Append(&quot;auth_token&quot;, data.Badge, ...... 雖然已經可以透過Cookie辦視出是誰登入，但這樣外漏在外面，不太好所以將資料編個碼 123456789101112131415161718192021222324252627282930313233343536public IActionResult Login(LoginModel data)&#123; if (data.Badge == &quot;Justin&quot; &amp;&amp; data.CipherCode == &quot;1111111111&quot;) &#123; //加密 var encode = &quot;&quot;; var aes = new AesCryptoServiceProvider(); SHA256CryptoServiceProvider sha256 = new SHA256CryptoServiceProvider(); MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); byte[] key = sha256.ComputeHash(Encoding.ASCII.GetBytes(&quot;12345678&quot;)); byte[] iv = md5.ComputeHash(Encoding.ASCII.GetBytes(&quot;12345678&quot;)); aes.Key = key; aes.IV = iv; var dataArray = Encoding.UTF8.GetBytes(data.Badge); using (var ms = new MemoryStream()) using (var cs = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write)) &#123; cs.Write(dataArray, 0, dataArray.Length); cs.FlushFinalBlock(); encode = Convert.ToBase64String(dataArray.ToArray()); &#125; HttpContext.Response.Cookies.Append(&quot;auth_token&quot;,encode, new CookieOptions &#123; HttpOnly = true, //不可以被前端修改 &#125; ); return RedirectToAction(nameof(HomeController.Index), &quot;Home&quot;); &#125; return View(nameof(HomeController.Index), data);&#125; 1 最後將加解密程序抽離為擴充CryptoStringExtension 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//CryptoStringExtension.cspublic static class CryptoStringExtension&#123; public static string Key &#123; get; set; &#125; = &quot;12345678&quot;; public static string Iv &#123; get; set; &#125; = &quot;12345678&quot;; public static string ToAesEncode(this string original) &#123; SHA256CryptoServiceProvider sha256 = new SHA256CryptoServiceProvider(); MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); byte[] key = sha256.ComputeHash(Encoding.ASCII.GetBytes(Key)); byte[] iv = md5.ComputeHash(Encoding.ASCII.GetBytes(Iv)); return ToAesEncode(original, key, iv); &#125; public static string ToAesEncode(this string original,byte[] key, byte[] iv) &#123; var encode = &quot;&quot;; var aes = new AesCryptoServiceProvider(); aes.Key = key; aes.IV = iv; var dataArray = Encoding.UTF8.GetBytes(original); using (var ms = new MemoryStream()) using (var cs = new CryptoStream(ms, aes.CreateEncryptor(), CryptoStreamMode.Write)) &#123; cs.Write(dataArray, 0, dataArray.Length); cs.FlushFinalBlock(); encode = Convert.ToBase64String(ms.ToArray()); &#125; return encode; &#125; public static string ToDecode(this string original) &#123; SHA256CryptoServiceProvider sha256 = new SHA256CryptoServiceProvider(); MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider(); byte[] key = sha256.ComputeHash(Encoding.ASCII.GetBytes(Key)); byte[] iv = md5.ComputeHash(Encoding.ASCII.GetBytes(Iv)); return ToDecode(original, key, iv); &#125; public static string ToDecode(this string original, byte[] key, byte[] iv) &#123; var encode = &quot;&quot;; try &#123; var aes = new AesCryptoServiceProvider(); aes.Key = key; aes.IV = iv; var dataArray = Convert.FromBase64String(original); using (var ms = new MemoryStream()) using (var cs = new CryptoStream(ms, aes.CreateDecryptor(), CryptoStreamMode.Write)) &#123; cs.Write(dataArray, 0, dataArray.Length); cs.FlushFinalBlock(); encode = Encoding.UTF8.GetString(ms.ToArray()); &#125; &#125; catch(Exception ex) &#123; encode = ex.Message; &#125; return encode; &#125;&#125; 在Account中的Login加密的部份改寫為 12//加密var encode = data.Badge.ToAesEncode(); 最後為沒簡單測試解密，我們在HomeController/Privacy 上加上解密的程序 12345var value = HttpContext.Request.Cookies.SingleOrDefault(x =&gt; x.Key == &quot;auth_token&quot;).Value;var decode = value.ToDecode();if (decode != &quot;Justin&quot;) return RedirectToAction(nameof(AccountController.Index)); 從Middleware判斷是否已登入雖然是完成一個簡單的登入程序，但為了知道每一個Request是否已登入，必需在每一個Action寫上判斷程式，實在太麻煩了，而這邊可以利用Middleware來處理，讓所有未登入都登到登入頁面。 12345678910111213141516171819202122232425public async Task Invoke(HttpContext context)&#123; var endpoint = context.GetEndpoint(); if (endpoint != null) &#123; var metadata = endpoint.Metadata; //1. 取得路徑資訊 ControllerActionDescriptor controllerAction = (ControllerActionDescriptor)metadata.SingleOrDefault(x =&gt; x.ToString() == &quot;Microsoft.AspNetCore.Mvc.Controllers.ControllerActionDescriptor&quot;); if (controllerAction.ControllerName != &quot;Account&quot;) &#123; var value = context.Request.Cookies.SingleOrDefault(x =&gt; x.Key == &quot;auth_token&quot;).Value; var decode = value.ToDecode(); // 2. 如果是空的或解碼失敗則導回登入頁面 if (String.IsNullOrEmpty(decode)) &#123; context.Response.Redirect(&quot;/Account/Index&quot;, false); return; &#125; &#125; &#125; await _next(context);&#125; 權限驗證這部份可以參考使用Session實作Login中的「客制化授權」，只需調整取得資料的方式，原本是從Session取得資料改變為從Cookie取得資料，這邊就不多作Demo了。","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"https://justinchang.ddns.net/categories/ASP-NET-Core/"}],"tags":[{"name":"Without Identity, Login,ASP.NETCore,Cookie","slug":"Without-Identity-Login-ASP-NETCore-Cookie","permalink":"https://justinchang.ddns.net/tags/Without-Identity-Login-ASP-NETCore-Cookie/"}]},{"title":"使用Cookie實作Login-Cookie 的使用","permalink":"https://justinchang.ddns.net/2021/04/06/%E4%BD%BF%E7%94%A8Cookie%E5%AF%A6%E4%BD%9CLogind%20-%20Cookie%20%E7%9A%84%E4%BD%BF%E7%94%A8/","text":"什麼是CookieCookie可以當作瀏覽器與伺服器的共用筆記本，在每一次的Request時，都會自動的把Cookie向伺服器傳遞，在伺服器每一次的Response時，也都會將Cookie自動傳遞回去。那瀏覽器怎判斷要把Cookie傳遞回去？這就要看Cookie的所記載的屬性來決定，後續的文章會再討論這部份。 Cookie的使用在 Asp.Net Core 可以直接使用，不需任何設定，直接使用Cooies.Append 12345public IActionResult Index()&#123; HttpContext.Response.Cookies.Append(&quot;Key&quot;, &quot;Value&quot;); return View();&#125; Cookie的欄位說明要先說設定之前先來講講在開發者工作中Cookie的每一個欄位的定義，其中第8項到10都是跟安全性有關系，其中SameSite的設定會影響到站台使用到第三方Cookie的使用。 Name: 就是Key Value: 就是Value Domain: 允許那一個host可以接收 Path: 請求 URL 中的 URL 路徑 Expires/Max-Age: 特定的日期或者經過一段特定的時間之後才會失效 Size:cookie的大小 HttpOnly: 只允許Http傳遞與，也就是說不可以使用JS來讀取，只能使用後端程式碼讀取 Secure: 只允許HTTPS使用，只允許有使用SSL的站台使用 SameSite: 跨站請求的方式寄送的限制設定，防止CSRF攻擊，這有點進階，詳細可以參考網站安全🔒再探同源政策，談 SameSite 設定對 Cookie 的影響與注意事項 Priority:優先順序，優先等級較低的會被優先被刪除 Cookie的參數設定在Cookie.Append中第三個參數CookieOptions就是用來設定上述的參數，可以移至定義後看的到全部可設定參數。 依照設定之後，可以看到cookie的變化 123456HttpContext.Response.Cookies.Append(&quot;Key&quot;, &quot;Value&quot;,new CookieOptions &#123; Expires=DateTime.Now.AddDays(1), HttpOnly=true, SameSite=SameSiteMode.Lax, Secure=true&#125;); HttpOnly的設定將HttpOnly設定改為True/False後，在使用document.cookie測試會發現，將HttpOnlu=true時，無法使用JS讀取，內容為空 Expires的設定將Expries設定改為DateTime.Now.AddSeconds(20) ，在超過時間後再次存取網頁時，cookie會消失 Cookie共編在後端從HttpContext.Request.cookies取得cookie後，從HttpContext.Response.cookies.Appen時送出修改後的cookie值 12345678910111213public IActionResult Index()&#123; var value = HttpContext.Request.Cookies.SingleOrDefault(x=&gt;x.Key==&quot;Key&quot;).Value; HttpContext.Response.Cookies.Append(&quot;Key&quot;, &quot;Value&quot;+value, new CookieOptions &#123; Expires=DateTime.Now.AddDays(1), //HttpOnly=true, SameSite=SameSiteMode.Lax, Secure=true &#125;); return View();&#125; 在前端從document.cookies直接修改，再更新畫面後，送回後端 使用js取得cookies時，是一個字串，而不同組成的格式是key1=value1;key2=value2;...;...，所以如果要作修改最好要另外處理字串拆分與組合","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"https://justinchang.ddns.net/categories/ASP-NET-Core/"}],"tags":[{"name":"Without Identity, Login,ASP.NETCore,Cookie","slug":"Without-Identity-Login-ASP-NETCore-Cookie","permalink":"https://justinchang.ddns.net/tags/Without-Identity-Login-ASP-NETCore-Cookie/"}]},{"title":"使用 AJAX 與 Action 接值問題","permalink":"https://justinchang.ddns.net/2021/04/01/%E4%BD%BF%E7%94%A8%20AJAX%20%E8%88%87%20Action%20%E6%8E%A5%E5%80%BC%E5%95%8F%E9%A1%8C/","text":"使用 AJAX 與 Action 接值問題？在使用AJAX時，常常會發生後端接不到值等等問題，通常都是邊寫邊Try到通為止，但時間一久又忘記怎樣的組合才對的，於是來作一個比較表吧，首先把會影響的變數列一下： 前端： content-type的設定 資料是否要序例化為字串 後端： FromBody是否要使用 在不同域的情境 415:Unsupported Media Typecors error:Cross-Origin Resource Sharing (CORS) is a standard that allows a server to relax the same-origin policy. 參數設定問題 情境假設： 使用JQuery的$.AJAX 後端使用ASP.NET Core MVC 沒有跨域問題 使用FromBody contentType data request application/json JSON.stringify OK application/json Object null none JSON.stringify 415 none Object 415 不使用FromBody contentType data request application/json JSON.stringify null application/json Object null none JSON.stringify null none object OK CORS問題 情境假設： 使用JQuery的$.AJAX 後端使用ASP.NET Core MVC 有跨域問題 站台是否允許可跨站 allow cross site &amp;&amp; use FromBody contentType data request response application/json JSON.stringify OK OK application/json Object null OK none JSON.stringify 415 none Object 415 allow cross site &amp;&amp; not use FromBody contentType data request response application/json JSON.stringify null OK application/json Object null OK none JSON.stringify null OK none Object OK OK not allow cross site &amp;&amp; use FromBody contentType data request response application/json JSON.stringify CORS error application/json Object CORS error none JSON.stringify CORS error none Object CORS error not allow cross site &amp;&amp; not use FromBody contentType data request response application/json JSON.stringify null CORS error application/json Object null CORS error none JSON.stringify null CORS error none Object OK CORS error 結論 使用ContentType為Json時，data一定要使用JSON.stringify 沒有使用ContentType時，data可以使用轉入Object 可以跨域與同站行為相同 不可跨域時 有使用FromBody，會直接出Cors error，進不了Action 沒使用FromBody，Response會出現Cors error, 且有機會把資料傳入Action 完整的腦圖完整的腦圖","categories":[{"name":"AJAX","slug":"AJAX","permalink":"https://justinchang.ddns.net/categories/AJAX/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://justinchang.ddns.net/tags/Web/"},{"name":"AJAX","slug":"AJAX","permalink":"https://justinchang.ddns.net/tags/AJAX/"},{"name":"ASP.NETCore","slug":"ASP-NETCore","permalink":"https://justinchang.ddns.net/tags/ASP-NETCore/"}]},{"title":"親子簡易手作餅乾","permalink":"https://justinchang.ddns.net/2021/03/29/%E8%A6%AA%E5%AD%90%E7%B0%A1%E6%98%93%E6%89%8B%E4%BD%9C%E9%A4%85%E4%B9%BE/","text":"最近燃起烘培魂，以前一直覺得會烘培的對我來說是一種遙不可及的事，受到微精通啟發，凡事作就對了，要前進的第一步就是Google，而第一篇就是 初學者必學～超簡易手工烤餅乾，覺得困難度不高，就開始動手Go Go 準備材料 奶油 100g 砂糖 40g 可以自行調整甜度 蛋黃 1 顆 可以依口味作調整 低筋麵粉 200g 與奶油比例為(1:2)右左 鮮奶 少許 如果麵團太乾時可以加上一些 最後可以加一些風味的醬料 巧克力醬(最好是巧克力粉) 比例計算 步驟 先將奶油打散或是融化成液狀後打發 將砂糖加入，與奶油充分混合 將蛋黃加入，再次充分混合 將麵份加入，充分混合至看不見白色麵粉 將完成好的麵團桿平 也可以利用夾鏈袋，可以桿出漂亮的麵皮 將麵皮冷藏10分鐘，這樣麵皮比較不會散掉，方便壓模 透過壓模將麵皮，製作出不一樣的圖案 要烤之前先將烤箱預熱，大約烤7~8分鐘 每一台烤箱的溫度都不一樣，這就要自行調控","categories":[{"name":"烘培","slug":"烘培","permalink":"https://justinchang.ddns.net/categories/%E7%83%98%E5%9F%B9/"}],"tags":[{"name":"親子","slug":"親子","permalink":"https://justinchang.ddns.net/tags/%E8%A6%AA%E5%AD%90/"},{"name":"烘培","slug":"烘培","permalink":"https://justinchang.ddns.net/tags/%E7%83%98%E5%9F%B9/"},{"name":"手作餅乾","slug":"手作餅乾","permalink":"https://justinchang.ddns.net/tags/%E6%89%8B%E4%BD%9C%E9%A4%85%E4%B9%BE/"},{"name":"微精通","slug":"微精通","permalink":"https://justinchang.ddns.net/tags/%E5%BE%AE%E7%B2%BE%E9%80%9A/"},{"name":"人生清單","slug":"人生清單","permalink":"https://justinchang.ddns.net/tags/%E4%BA%BA%E7%94%9F%E6%B8%85%E5%96%AE/"}]},{"title":"開發/線上小工具","permalink":"https://justinchang.ddns.net/2021/03/25/%E9%96%8B%E7%99%BC_%E7%B7%9A%E4%B8%8A%E5%B0%8F%E5%B7%A5%E5%85%B7/","text":"開發/線上小工具產生Html表格 https://www.tablesgenerator.com/html_tableshttps://divtable.com/table-styler/ cron 表達 https://crontab.guru/ UML產生語 https://plantuml.com/zh/sequence-diagram Regex 正規測試 https://regex101.com/ JsonToClass https://app.quicktype.io/?l=csharp 文字模板Scriban https://github.com/lunet-io/scribanhttps://scribanonline.azurewebsites.net/ 文字轉計算mXparser http://mathparser.org/ suggest https://vuejsexamples.com/mention-popper-for-input-and-textarea-with-vue-js/https://github.com/pfrazee/suggest-boxhttps://blog.csdn.net/kingwolfofsky/article/details/6586029 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;InputPostion&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;textarea id&#x3D;&quot;text&quot; onkeyup&#x3D;&quot;show(this) &quot; style&#x3D;&quot;width: 340px; height: 210px; &quot;&gt;&lt;&#x2F;textarea&gt; &lt;br &#x2F;&gt; &lt;input type&#x3D;&quot;text&quot; onkeyup&#x3D;&quot;show(this) &quot; style&#x3D;&quot;width: 340px; &quot; &#x2F;&gt; &lt;div id&#x3D;&quot;show&quot; style&#x3D;&quot;width: 34px; height: 13px; background: #eee; position: absolute;border:1px solid grey;font-size:13px; display:none; &quot;&gt;Tips&lt;&#x2F;div&gt; &lt;script&gt; var suggester &#x3D; &#123; &#x2F;** * 获取输入光标在页面中的坐标 * @param &#123;HTMLElement&#125; 输入框元素 * @return &#123;Object&#125; 返回left和top,bottom *&#x2F; getInputPositon: function(elem) &#123; if (document.selection) &#123; &#x2F;&#x2F;IE Support elem.focus(); var Sel &#x3D; document.selection.createRange(); return &#123; left: Sel.boundingLeft, top: Sel.boundingTop, bottom: Sel.boundingTop + Sel.boundingHeight &#125;; &#125; else &#123; var that &#x3D; this; var cloneDiv &#x3D; &#39;&#123;$clone_div&#125;&#39; var cloneLeft &#x3D; &#39;&#123;$cloneLeft&#125;&#39; var cloneFocus &#x3D; &#39;&#123;$cloneFocus&#125;&#39; var cloneRight &#x3D; &#39;&#123;$cloneRight&#125;&#39; var none &#x3D; &#39;&lt;span style&#x3D;&quot;white-space:pre-wrap;&quot;&gt; &lt;&#x2F;span&gt;&#39; var div &#x3D; elem[cloneDiv] || document.createElement(&#39;div&#39;) var focus &#x3D; elem[cloneFocus] || document.createElement(&#39;span&#39;) var text &#x3D; elem[cloneLeft] || document.createElement(&#39;span&#39;) var offset &#x3D; that._offset(elem) var index &#x3D; this._getFocus(elem) var focusOffset &#x3D; &#123; left: 0, top: 0 &#125;; if (!elem[cloneDiv]) &#123; elem[cloneDiv] &#x3D; div, elem[cloneFocus] &#x3D; focus; elem[cloneLeft] &#x3D; text; div.appendChild(text); div.appendChild(focus); document.body.appendChild(div); focus.innerHTML &#x3D; &#39;|&#39;; focus.style.cssText &#x3D; &#39;display:inline-block;width:0px;overflow:hidden;z-index:-100;word-wrap:break-word;word-break:break-all;&#39;; div.className &#x3D; this._cloneStyle(elem); div.style.cssText &#x3D; &#39;visibility:hidden;display:inline-block;position:absolute;z-index:-100;word-wrap:break-word;word-break:break-all;overflow:hidden;&#39;; &#125;; div.style.left &#x3D; this._offset(elem).left + &quot;px&quot;; div.style.top &#x3D; this._offset(elem).top + &quot;px&quot;; var strTmp &#x3D; elem.value.substring(0, index).replace(&#x2F;&lt;&#x2F;g, &#39;&lt;&#39;).replace(&#x2F;&gt;&#x2F;g, &#39;&gt;&#39;).replace(&#x2F;\\n&#x2F;g, &#39;&lt;br&#x2F;&gt;&#39;).replace(&#x2F;\\s&#x2F;g, none); text.innerHTML &#x3D; strTmp; focus.style.display &#x3D; &#39;inline-block&#39;; try &#123; focusOffset &#x3D; this._offset(focus); &#125; catch (e) &#123;&#125;; focus.style.display &#x3D; &#39;none&#39;; return &#123; left: focusOffset.left, top: focusOffset.top, bottom: focusOffset.bottom &#125;; &#125; &#125;, &#x2F;&#x2F; 克隆元素样式并返回类 _cloneStyle: function(elem, cache) &#123; if (!cache &amp;&amp; elem[&#39;$&#123;cloneName&#125;&#39;]) return elem[&#39;$&#123;cloneName&#125;&#39;]; var className, name, rstyle &#x3D; &#x2F;^(number|string)$&#x2F;; var rname &#x3D; &#x2F;^(content|outline|outlineWidth)$&#x2F;; &#x2F;&#x2F;Opera: content; IE8:outline &amp;&amp; outlineWidth var cssText &#x3D; [], sStyle &#x3D; elem.style; for (name in sStyle) &#123; if (!rname.test(name)) &#123; val &#x3D; this._getStyle(elem, name); if (val !&#x3D;&#x3D; &#39;&#39; &amp;&amp; rstyle.test(typeof val)) &#123; &#x2F;&#x2F; Firefox 4 name &#x3D; name.replace(&#x2F;([A-Z])&#x2F;g, &quot;-$1&quot;).toLowerCase(); cssText.push(name); cssText.push(&#39;:&#39;); cssText.push(val); cssText.push(&#39;;&#39;); &#125;; &#125;; &#125;; cssText &#x3D; cssText.join(&#39;&#39;); elem[&#39;$&#123;cloneName&#125;&#39;] &#x3D; className &#x3D; &#39;clone&#39; + (new Date).getTime(); this._addHeadStyle(&#39;.&#39; + className + &#39;&#123;&#39; + cssText + &#39;&#125;&#39;); return className; &#125;, &#x2F;&#x2F; 向页头插入样式 _addHeadStyle: function(content) &#123; var style &#x3D; this._style[document]; if (!style) &#123; style &#x3D; this._style[document] &#x3D; document.createElement(&#39;style&#39;); document.getElementsByTagName(&#39;head&#39;)[0].appendChild(style); &#125;; style.styleSheet &amp;&amp; (style.styleSheet.cssText +&#x3D; content) || style.appendChild(document.createTextNode(content)); &#125;, _style: &#123;&#125;, &#x2F;&#x2F; 获取最终样式 _getStyle: &#39;getComputedStyle&#39; in window ? function(elem, name) &#123; return getComputedStyle(elem, null)[name]; &#125; : function(elem, name) &#123; return elem.currentStyle[name]; &#125;, &#x2F;&#x2F; 获取光标在文本框的位置 _getFocus: function(elem) &#123; var index &#x3D; 0; if (document.selection) &#123; &#x2F;&#x2F; IE Support elem.focus(); var Sel &#x3D; document.selection.createRange(); if (elem.nodeName &#x3D;&#x3D;&#x3D; &#39;TEXTAREA&#39;) &#123; &#x2F;&#x2F;textarea var Sel2 &#x3D; Sel.duplicate(); Sel2.moveToElementText(elem); var index &#x3D; -1; while (Sel2.inRange(Sel)) &#123; Sel2.moveStart(&#39;character&#39;); index++; &#125;; &#125; else if (elem.nodeName &#x3D;&#x3D;&#x3D; &#39;INPUT&#39;) &#123; &#x2F;&#x2F; input Sel.moveStart(&#39;character&#39;, -elem.value.length); index &#x3D; Sel.text.length; &#125; &#125; else if (elem.selectionStart || elem.selectionStart &#x3D;&#x3D; &#39;0&#39;) &#123; &#x2F;&#x2F; Firefox support index &#x3D; elem.selectionStart; &#125; return (index); &#125;, &#x2F;&#x2F; 获取元素在页面中位置 _offset: function(elem) &#123; var box &#x3D; elem.getBoundingClientRect(), doc &#x3D; elem.ownerDocument, body &#x3D; doc.body, docElem &#x3D; doc.documentElement; var clientTop &#x3D; docElem.clientTop || body.clientTop || 0, clientLeft &#x3D; docElem.clientLeft || body.clientLeft || 0; var top &#x3D; box.top + (self.pageYOffset || docElem.scrollTop) - clientTop, left &#x3D; box.left + (self.pageXOffset || docElem.scrollLeft) - clientLeft; return &#123; left: left, top: top, right: left + box.width, bottom: top + box.height &#125;; &#125; &#125;; function getPosition(ctrl) &#123; var p &#x3D; suggester.getInputPositon(ctrl); document.getElementById(&#39;show&#39;).style.left &#x3D; p.left + &quot;px&quot;; document.getElementById(&#39;show&#39;).style.top &#x3D; p.bottom + &quot;px&quot;; &#125; &lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript &quot;&gt; function show(elem) &#123; var p &#x3D; suggester.getInputPositon(elem); var s &#x3D; document.getElementById(&#39;show&#39;); s.style.top &#x3D; p.bottom + &#39;px&#39;; s.style.left &#x3D; p.left + &#39;px&#39;; s.style.display &#x3D; &#39;inherit&#39;; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; POSMAN從Chrome複制curl 從chrome開發者工具選擇netword，選擇copy的request,滑鼠右鍵選擇copy/copy as cURL(bash) 開啟postman，從上方import，後選擇Paste Raw Text 上述完成後，執行import，會出現「error while importing curl typeerror invalid format for curl.」，這是因為postman不支援--compressed語法，刪除後再執行就解決了 https://github.com/postmanlabs/postman-app-support/issues/5735 目錄匯出檔案 透過簡單dos指令 1dir &#x2F;b &#x2F;s *.* &gt; file_list.xls 將資料夾底下的全部檔案列表出來，並儲存成 Excel 檔案 使用黑大C#程式 【潛盾機】將檔案結構匯成Excel文件 使用「DirPrintOK 」 DirPrintOK 匯出目錄下的資料夾、檔案名稱也可以很簡單 如果是使用WIN10先全選，再使用「複製路徑」 如果有使用Chrome直接將資料匣拖洩到Chrome","categories":[{"name":"工具","slug":"工具","permalink":"https://justinchang.ddns.net/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"開發","slug":"開發","permalink":"https://justinchang.ddns.net/tags/%E9%96%8B%E7%99%BC/"},{"name":"線上","slug":"線上","permalink":"https://justinchang.ddns.net/tags/%E7%B7%9A%E4%B8%8A/"},{"name":"小工具","slug":"小工具","permalink":"https://justinchang.ddns.net/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"}]},{"title":"使用Session實作Login","permalink":"https://justinchang.ddns.net/2021/03/25/%E4%BD%BF%E7%94%A8Session%E5%AF%A6%E4%BD%9CLogin/","text":"使用Session實作Login啟動session要在 ASP.NET Core 啟用 session 只需在 Startup.cs 兩個步驟： 在ConfigureServices加上session服務 12345public void ConfigureServices(IServiceCollection services)&#123; ... services.AddSession(); //加上session服務&#125; 在Configure加上Middoware 123456789101112131415public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123; .... app.UseAuthorization(); app.UseSession(); //加上Middoware app.UseEndpoints(endpoints =&gt; &#123; endpoints.MapControllerRoute( name: &quot;default&quot;, pattern: &quot;&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;&quot;); &#125;);&#125; 存取Session，在HomeController的Privacy加上存取 session 語法, 12345678public IActionResult Privacy()&#123; var us = HttpContext.Session.GetString(&quot;User&quot;); var pd = HttpContext.Session.GetString(&quot;Password&quot;); HttpContext.Session.SetString(&quot;User&quot;, &quot;Demo&quot;); HttpContext.Session.SetString(&quot;Password&quot;, &quot;123&quot;); return View();&#125; 完成上面的步驟，來測試一下應該不難發現在開啟Privacy時，Cookies出現了 .AspNetCore.Session，Value則是一長串，明明是使用Session為什麼會出現Cooke呢？這是因為HTTP是無狀態,為了辦認出是誰來請求，所以必需將SessionId回傳到後端，而 .AspNetCore.Session就是SessionId， 接下來用Debug來觀察Session的存取在第一次進入Privacy時 Get Session 是 null,第二次進入時 Get Session 就會取得上一次存入的值 Session的安全設定基於資安考量必須對session的權限作限縮，詳細的說明請參閱SessionOptions 類別 不用使用預設的 cookie Name session存活時間，預設值是 20 分鐘 限制session取出的時間，預設值是1分鐘 限制第三方讀取Cookie 12345678910public void ConfigureServices(IServiceCollection services)&#123; services.AddControllersWithViews(); services.AddSession(options=&gt;&#123; options.Cookie.Name = &quot;WithSessionId&quot;; //設定Cookie的Name名稱 options.Cookie.SecurePolicy = CookieSecurePolicy.Always; //只允許HTTPS讀取Cookie options.Cookie.SameSite = SameSiteMode.Lax; //限制第三方Cookie使用 options.IdleTimeout = TimeSpan.FromSeconds(10); //設定Session有效時間 &#125;);&#125; 重新啟動後，再次查看一下開發者工具，就會發現Cookie的Key改變為「WithSessionId」 再來測試一下經過10秒後，讀取Session的情況 實作登入與登出Action 新增登入用ViewModel規避常用的帳號密碼關鍵字，因為現在資安的議題被大家所重視，所以大部份的公司都會使用源碼檢測工具來產生報告，會從程式的特徵來判讀是否有資安疑慮，但問題來了大部的的檢測工具會把Id、User、Password等，經常用來作權限管理的關鍵字抓出在報告中呈現(通常是中風險)，雖然檢測工具的用意是用來提醒開發人員必需要特別留意或必需加強管理就可以排外，但往往「沒有人」可以負責放行，因為一但決定放行，將來被究責時會背上一鍋，所以在設計當初迴避就是最簡單的方式，也可以用一些公司自定義的縮寫也是一個不錯的選擇。 123456789101112131415161718public class LoginModel&#123; /// &lt;summary&gt; /// 識別ID(不使用User、Name、ID等，減少被弱掃或攻擊到的機會) /// &lt;/summary&gt; [Required] [StringLength(30,ErrorMessage =&quot;長度不符合規定&quot;,MinimumLength =3)] [Display(Name =&quot;帳號&quot;)] public string Badge &#123; get; set; &#125; /// &lt;summary&gt; /// 密碼(不使用Password，減少被弱掃或攻擊到的機會) /// &lt;/summary&gt; [Required] [StringLength(30, ErrorMessage = &quot;長度不符合規定&quot;, MinimumLength = 10)] [DataType(DataType.Password)] [Display(Name =&quot;密碼&quot;)] public string CipherCode &#123; get; set; &#125;&#125; 透過ViewModel產生畫面 實作登錄Action 目前並未有實作帳號儲存的方式，所以先HardCode一組帳號作為帳密驗證,真實的世界必須要將帳號存入資料庫中，並且密碼最少一種加密的方式，不可在存入未加密的字串。 在登入後還會去取得授權(可以操作系統的Function或功能)，在登入也會將此角色、授權及使用者相關系資訊存入session中，提供給系統作為授權的判斷。 最後登出只要呼叫HttpContext.Session.Clear()就以清空這一組sessionId所存的資料。 12345678910111213141516public IActionResult Login(LoginModel login)&#123; if(login.Badge==&quot;Justin&quot; &amp;&amp; login.CipherCode == &quot;1234567890&quot;) &#123; //當登入成功後，將使用者資訊存入Session中 HttpContext.Session.SetString(&quot;User&quot;, login.Badge); HttpContext.Session.SetString(&quot;Role&quot;, &quot;administraotr&quot;); return RedirectToAction(nameof(HomeController.Index), &quot;Home&quot;); &#125; return View(nameof(AccountController.Index), login);&#125;public IActionResult Logout()&#123; HttpContext.Session.Clear(); return RedirectToAction(nameof(HomeController.Index), &quot;Home&quot;);&#125; 重構session存取, 使用擴充方式session在存取只能一個key取出一個value，相反也是一樣，只有清空可以用一個指令完成，而在系統大量操作session時這就會顯的非常麻煩, 所以可以針對Session擴允的個方法，來操作一整個物件的存入與取得值在 建立UserInfo 12345public class UserInfo&#123; public string Name &#123; get; set; &#125; public string Role &#123; get; set; &#125;&#125; 建立SessionExtenstion 1234567891011121314public static class SessionExtension&#123; const string KEY= &quot;SESSION&quot;; public static void Set&lt;T&gt;(this ISession session,T Data) &#123; session.SetString(KEY, JsonSerializer.Serialize(Data)); &#125; public static T Get&lt;T&gt;(this ISession session)where T:new () &#123; var data = session.GetString(KEY); return data!=null?JsonSerializer.Deserialize&lt;T&gt;(data):new T(); &#125;&#125; 調整Account中存取Session的方式 存入 12345HttpContext.Session.Set(new UserInfo()&#123; Name = login.Badge, Role = &quot;administraotr&quot;&#125;); 讀取 1var userinfo = HttpContext.Session.Get&lt;UserInfo&gt;(); 客制化授權由於原生的Authorize不支援session，所以可以簡單寫一個客制的授權方式，只判斷是是否已登入，否則跳回首頁 SessionAuthorizeAttribute 12345[AttributeUsage(AttributeTargets.All, AllowMultiple = false)]public class SessionAuthorizeAttribute:Attribute&#123;&#125; SessionAuthorizeMiddleware這邊主要知道的是怎麼取得Meadata(也就是Attribute),與怎麼判斷有掛上所定義的,再者是Response怎麼回應，最後是每個await _next(content) 之後都必須return; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class SessionAuthorizeMiddleware&#123; private readonly RequestDelegate _next; private string _message; public SessionAuthorizeMiddleware(RequestDelegate next) &#123; _next = next; &#125; public async Task Invoke(HttpContext context) &#123; //1. 取得有所有的Meatdata var metaData = context.GetEndpoint().Metadata; //2. 是否有使用SessionAuthorizeAttribute var hasSessionAuthorizeAttribute = metaData.Any(x =&gt; x.ToString().EndsWith(nameof(SessionAuthorizeAttribute))); //3. 沒使用不判斷 if (!hasSessionAuthorizeAttribute) &#123; await _next(context); return; &#125; //4. 判斷權角色是否是管理者 var userInfo = context.Session.Get&lt;UserInfo&gt;(); if (userInfo != null &amp;&amp; userInfo.Role == &quot;administrator&quot;) &#123; await _next(context); return; &#125; //5. 如果未登入，則回應403 if (userInfo?.Name == null) &#123; context.Response.StatusCode = (int)HttpStatusCode.Forbidden; _message = &quot;&#123;\\&quot;code\\&quot;:403,\\&quot;message\\&quot;:\\&quot;無訪問權限 Forbidden\\&quot;&#125;&quot;; context.Response.ContentType = &quot;application/json&quot;; await context.Response.Body.WriteAsync(Encoding.UTF8.GetBytes(_message), 0, Encoding.UTF8.GetBytes(_message).Length); return; &#125; //6. 如果未被授權，則回應401 context.Response.StatusCode = (int)HttpStatusCode.Unauthorized; _message = &quot;&#123;\\&quot;code\\&quot;:401,\\&quot;message\\&quot;:\\&quot;需要授權 Forbidden\\&quot;&#125;&quot;; context.Response.ContentType = &quot;application/json&quot;; await context.Response.Body.WriteAsync(Encoding.UTF8.GetBytes(_message), 0, Encoding.UTF8.GetBytes(_message).Length); &#125;&#125; Starup掛上SessionAuthorizeMiddleware，在 app.UseSession();之後 1app.UseMiddleware&lt;SessionAuthorizeMiddleware&gt;(); Demo我們在Privacy加上[SessionAuthrize]再進行測試 這樣就是一個簡單使用Session實作具有帳號管理的功能，不過這範例有些部份沒有完成，像是帳號的儲存、角色的設定等等。 參考：Session and state management in ASP.NET CoreCookie 的 SameSite 屬性ASP.NET Core 3中的自定義授權asp.net Core 中AuthorizationHandler 实现自定义授权","categories":[{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"https://justinchang.ddns.net/categories/ASP-NET-Core/"}],"tags":[{"name":"ASP.NETCore","slug":"ASP-NETCore","permalink":"https://justinchang.ddns.net/tags/ASP-NETCore/"},{"name":"WithoutIdentityLogin","slug":"WithoutIdentityLogin","permalink":"https://justinchang.ddns.net/tags/WithoutIdentityLogin/"},{"name":"Login","slug":"Login","permalink":"https://justinchang.ddns.net/tags/Login/"},{"name":"Session","slug":"Session","permalink":"https://justinchang.ddns.net/tags/Session/"}]},{"title":"自學英文-聽力","permalink":"https://justinchang.ddns.net/2021/03/25/%E8%87%AA%E5%AD%B8%E8%8B%B1%E6%96%87-%E8%81%BD%E5%8A%9B/","text":"我自已認為我的聽力能力應該是0，所以從頭開始學習，並記錄一些在學習的過程中的一些領悟，好萬事起頭難，我在VoiceTube選擇A1程度的影片，通過聽寫並打出(或寫出)所聽到的英文，剛開始一句句開始，每一句先看字幕，並重覆聽多次，試圖聽出每一個字。 English in a Minute: Burn the Candle at Both Ends in a 的連音，可以直接聽成弱弱的「依內」 the 如果在句子中間可以聽成「的」，在句中前面聽成「立」 at 可聽成「了」 both ends 的連音可以聽成bothends但重音在ends, both ends :兩端，重音在ends Burn the candle at both ends I’ll be 連音，聽成：阿爾比","categories":[{"name":"英文學習","slug":"英文學習","permalink":"https://justinchang.ddns.net/categories/%E8%8B%B1%E6%96%87%E5%AD%B8%E7%BF%92/"}],"tags":[{"name":"English Study","slug":"English-Study","permalink":"https://justinchang.ddns.net/tags/English-Study/"},{"name":"英文","slug":"英文","permalink":"https://justinchang.ddns.net/tags/%E8%8B%B1%E6%96%87/"},{"name":"自學","slug":"自學","permalink":"https://justinchang.ddns.net/tags/%E8%87%AA%E5%AD%B8/"},{"name":"聽力","slug":"聽力","permalink":"https://justinchang.ddns.net/tags/%E8%81%BD%E5%8A%9B/"}]}],"categories":[{"name":"原碼掃描","slug":"原碼掃描","permalink":"https://justinchang.ddns.net/categories/%E5%8E%9F%E7%A2%BC%E6%8E%83%E6%8F%8F/"},{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/categories/JAVA/"},{"name":"Oracle","slug":"Oracle","permalink":"https://justinchang.ddns.net/categories/Oracle/"},{"name":"ASP.NET Core","slug":"ASP-NET-Core","permalink":"https://justinchang.ddns.net/categories/ASP-NET-Core/"},{"name":"AJAX","slug":"AJAX","permalink":"https://justinchang.ddns.net/categories/AJAX/"},{"name":"烘培","slug":"烘培","permalink":"https://justinchang.ddns.net/categories/%E7%83%98%E5%9F%B9/"},{"name":"工具","slug":"工具","permalink":"https://justinchang.ddns.net/categories/%E5%B7%A5%E5%85%B7/"},{"name":"英文學習","slug":"英文學習","permalink":"https://justinchang.ddns.net/categories/%E8%8B%B1%E6%96%87%E5%AD%B8%E7%BF%92/"}],"tags":[{"name":"弱點處理","slug":"弱點處理","permalink":"https://justinchang.ddns.net/tags/%E5%BC%B1%E9%BB%9E%E8%99%95%E7%90%86/"},{"name":"CodeReview","slug":"CodeReview","permalink":"https://justinchang.ddns.net/tags/CodeReview/"},{"name":"CheckMarx","slug":"CheckMarx","permalink":"https://justinchang.ddns.net/tags/CheckMarx/"},{"name":"Eclipse","slug":"Eclipse","permalink":"https://justinchang.ddns.net/tags/Eclipse/"},{"name":"JAVA","slug":"JAVA","permalink":"https://justinchang.ddns.net/tags/JAVA/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://justinchang.ddns.net/tags/Mybatis/"},{"name":"ORM","slug":"ORM","permalink":"https://justinchang.ddns.net/tags/ORM/"},{"name":"Oracle","slug":"Oracle","permalink":"https://justinchang.ddns.net/tags/Oracle/"},{"name":"Win10","slug":"Win10","permalink":"https://justinchang.ddns.net/tags/Win10/"},{"name":"VSCode","slug":"VSCode","permalink":"https://justinchang.ddns.net/tags/VSCode/"},{"name":"Spring","slug":"Spring","permalink":"https://justinchang.ddns.net/tags/Spring/"},{"name":"Web","slug":"Web","permalink":"https://justinchang.ddns.net/tags/Web/"},{"name":"Without Identity, Login,ASP.NETCore,Cookie","slug":"Without-Identity-Login-ASP-NETCore-Cookie","permalink":"https://justinchang.ddns.net/tags/Without-Identity-Login-ASP-NETCore-Cookie/"},{"name":"AJAX","slug":"AJAX","permalink":"https://justinchang.ddns.net/tags/AJAX/"},{"name":"ASP.NETCore","slug":"ASP-NETCore","permalink":"https://justinchang.ddns.net/tags/ASP-NETCore/"},{"name":"親子","slug":"親子","permalink":"https://justinchang.ddns.net/tags/%E8%A6%AA%E5%AD%90/"},{"name":"烘培","slug":"烘培","permalink":"https://justinchang.ddns.net/tags/%E7%83%98%E5%9F%B9/"},{"name":"手作餅乾","slug":"手作餅乾","permalink":"https://justinchang.ddns.net/tags/%E6%89%8B%E4%BD%9C%E9%A4%85%E4%B9%BE/"},{"name":"微精通","slug":"微精通","permalink":"https://justinchang.ddns.net/tags/%E5%BE%AE%E7%B2%BE%E9%80%9A/"},{"name":"人生清單","slug":"人生清單","permalink":"https://justinchang.ddns.net/tags/%E4%BA%BA%E7%94%9F%E6%B8%85%E5%96%AE/"},{"name":"開發","slug":"開發","permalink":"https://justinchang.ddns.net/tags/%E9%96%8B%E7%99%BC/"},{"name":"線上","slug":"線上","permalink":"https://justinchang.ddns.net/tags/%E7%B7%9A%E4%B8%8A/"},{"name":"小工具","slug":"小工具","permalink":"https://justinchang.ddns.net/tags/%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"name":"WithoutIdentityLogin","slug":"WithoutIdentityLogin","permalink":"https://justinchang.ddns.net/tags/WithoutIdentityLogin/"},{"name":"Login","slug":"Login","permalink":"https://justinchang.ddns.net/tags/Login/"},{"name":"Session","slug":"Session","permalink":"https://justinchang.ddns.net/tags/Session/"},{"name":"English Study","slug":"English-Study","permalink":"https://justinchang.ddns.net/tags/English-Study/"},{"name":"英文","slug":"英文","permalink":"https://justinchang.ddns.net/tags/%E8%8B%B1%E6%96%87/"},{"name":"自學","slug":"自學","permalink":"https://justinchang.ddns.net/tags/%E8%87%AA%E5%AD%B8/"},{"name":"聽力","slug":"聽力","permalink":"https://justinchang.ddns.net/tags/%E8%81%BD%E5%8A%9B/"}]}